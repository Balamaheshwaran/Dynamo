using System;
using System.Collections.Generic;
using System.Reactive.Linq;
using System.Windows.Media.Media3D;
using System.Linq;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;

namespace Dynamo
{
    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, Visualization> visualizations 
            = new Dictionary<string, Visualization>();

        #endregion

        #region public properties

        /// <summary>
        /// A collection of objects to be stored for visualization.
        /// The first item in the tuple is is the list of geometry.
        /// The second item in the tuple is the most recent render geometry.
        /// The third item in the tuple is a flag marking the node as requiring visualization update
        /// </summary>
        public Dictionary<string, Visualization> Visualizations
        {
            get { return visualizations; }
            set { visualizations = value; }
        }

        #endregion

        #region events

        public event EventHandler VisualizationUpdateComplete;
        public virtual void OnVisualizationUpdateComplete(object sender, EventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        #endregion

        public VisualizationManager()
        {
            dynSettings.Controller.DynamoModel.NodeAdded += new NodeHandler(DynamoModel_NodeAdded);
            dynSettings.Controller.DynamoModel.NodeDeleted += new NodeHandler(DynamoModel_NodeDeleted);
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event. Unregisters a node from visualization.
        /// Triggers an update to the visualizations after un-registering a node
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeDeleted(NodeModel node)
        {
            if (node is IDrawable)
                UnregisterFromVisualization(node);

            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the model's NodeAdded event. Registers a node for visualization.
        /// Triggers an update to the visualizations after registering a node.
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeAdded(NodeModel node)
        {
            if (node is IDrawable)
                RegisterForVisualization(node);

            UpdateVisualizations();
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="id">The node to register for visualization</param>
        public virtual void RegisterForVisualization(NodeModel node)
        {
            //add a key in the dictionary
            if (!Visualizations.ContainsKey(node.GUID.ToString()))
            {
                var viz = new Visualization();
                Visualizations.Add(node.GUID.ToString(), new Visualization());
            }
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="id">The node to unregister from visualization</param>
        public virtual void UnregisterFromVisualization(NodeModel node)
        {
            if (Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Remove(node.GUID.ToString());
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Description.Clear());
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        /// <summary>
        /// Marks a visualization as requiring an update and clears its geometry collection.
        /// </summary>
        /// <param name="node">The node whose visualization will be updated.</param>
        public void MarkForUpdate(NodeModel node)
        {
            var v = Visualizations[node.GUID.ToString()];
            v.RequiresUpdate = true;
            v.Geometry.Clear();
        }

        public List<IDrawable> GetUpstreamIDrawable(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<IDrawable>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;
                var drawable = node as IDrawable;

                if (node.IsVisible && drawable != null)
                    drawables.Add(drawable);

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamIDrawable(node.Inputs));
                else
                    continue; // don't bother checking if function

                //if the node is function then get all the 
                //drawables inside that node. only do this if the
                //node's workspace is the home space to avoid infinite
                //recursion in the case of custom nodes in custom nodes
                if (node is Function && node.WorkSpace == dynSettings.Controller.DynamoModel.HomeSpace)
                {
                    var func = (Function)node;
                    IEnumerable<NodeModel> topElements = func.Definition.Workspace.GetTopMostNodes();
                    foreach (NodeModel innerNode in topElements)
                    {
                        drawables.AddRange(GetUpstreamIDrawable(innerNode.Inputs));
                    }
                }
            }

            return drawables;
        }
        
    }
}
