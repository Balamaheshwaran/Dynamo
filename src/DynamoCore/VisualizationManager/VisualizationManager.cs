using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Media.Media3D;
using System.Linq;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;

namespace Dynamo
{
    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, Visualization> visualizations 
            = new Dictionary<string, Visualization>();

        #endregion

        #region public properties

        /// <summary>
        /// A collection of objects to be stored for visualization.
        /// The first item in the tuple is is the list of geometry.
        /// The second item in the tuple is the most recent render geometry.
        /// The third item in the tuple is a flag marking the node as requiring visualization update
        /// </summary>
        public Dictionary<string, Visualization> Visualizations
        {
            get { return visualizations; }
            set { visualizations = value; }
        }

        #endregion

        #region events

        public event EventHandler VisualizationUpdateComplete;
        public virtual void OnVisualizationUpdateComplete(object sender, EventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        #endregion

        public VisualizationManager()
        {
            dynSettings.Controller.DynamoModel.NodeAdded += new NodeHandler(DynamoModel_NodeAdded);
            dynSettings.Controller.DynamoModel.NodeDeleted += new NodeHandler(DynamoModel_NodeDeleted);
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event. Unregisters a node from visualization.
        /// Triggers an update to the visualizations after un-registering a node
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeDeleted(NodeModel node)
        {
            if (node is IDrawable)
                UnregisterFromVisualization(node);

            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the model's NodeAdded event. Registers a node for visualization.
        /// Triggers an update to the visualizations after registering a node.
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeAdded(NodeModel node)
        {
            if (node is IDrawable)
                RegisterForVisualization(node);

            UpdateVisualizations();
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="id">The node to register for visualization</param>
        public virtual void RegisterForVisualization(NodeModel node)
        {
            //add a key in the dictionary
            if (!Visualizations.ContainsKey(node.GUID.ToString()))
            {
                var viz = new Visualization();
                Visualizations.Add(node.GUID.ToString(), new Visualization());
            }
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="id">The node to unregister from visualization</param>
        public virtual void UnregisterFromVisualization(NodeModel node)
        {
            if (Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Remove(node.GUID.ToString());
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Description.Clear());
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            //override in child classes
        }

        /// <summary>
        /// Marks a visualization as requiring an update and clears its geometry collection.
        /// </summary>
        /// <param name="node">The node whose visualization will be updated.</param>
        public void MarkForUpdate(NodeModel node)
        {
            var v = Visualizations[node.GUID.ToString()];
            v.RequiresUpdate = true;
            v.Geometry.Clear();
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node.
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public RenderDescription RenderUpstream(NodeModel node)
        {
            var watch = new Stopwatch();
            watch.Start();

            var drawables = GetUpstreamIDrawableIds(node.Inputs);
            
            var ids = from viz in dynSettings.Controller.VisualizationManager.Visualizations
                      where drawables.Contains(viz.Key)
                      select viz;

            var rd = new RenderDescription();

            var keyValuePairs = ids as KeyValuePair<string, Visualization>[] ?? ids.ToArray();

            var pts = keyValuePairs.SelectMany(x => x.Value.Description.Points);
            var lines = keyValuePairs.SelectMany(x => x.Value.Description.Lines);
            var meshes = keyValuePairs.SelectMany(x => x.Value.Description.Meshes).ToList();
            var xs = keyValuePairs.SelectMany(x => x.Value.Description.XAxisPoints);
            var ys = keyValuePairs.SelectMany(x => x.Value.Description.YAxisPoints);
            var zs = keyValuePairs.SelectMany(x => x.Value.Description.ZAxisPoints);
            rd.Points.AddRange(pts);
            rd.Lines.AddRange(lines);
            rd.Meshes.AddRange(meshes);
            rd.XAxisPoints.AddRange(xs);
            rd.YAxisPoints.AddRange(ys);
            rd.ZAxisPoints.AddRange(zs);

            watch.Stop();
            Debug.WriteLine(string.Format("{0} ellapsed for aggregating geometry for watch.", watch.Elapsed));

            return rd;
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <returns>A collection of strings.</returns>
        private List<string> GetUpstreamIDrawableIds(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<string>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;
                var drawable = node as IDrawable;

                if (node.IsVisible && drawable != null)
                    drawables.Add(node.GUID.ToString());

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamIDrawableIds(node.Inputs));
                else
                    continue; // don't bother checking if function

                //if the node is function then get all the 
                //drawables inside that node. only do this if the
                //node's workspace is the home space to avoid infinite
                //recursion in the case of custom nodes in custom nodes
                if (node is Function && node.WorkSpace == dynSettings.Controller.DynamoModel.HomeSpace)
                {
                    var func = (Function)node;
                    IEnumerable<NodeModel> topElements = func.Definition.Workspace.GetTopMostNodes();
                    foreach (NodeModel innerNode in topElements)
                    {
                        drawables.AddRange(GetUpstreamIDrawableIds(innerNode.Inputs));
                    }
                }
            }

            return drawables;
        }

        /// <summary>
        /// A utility method for merging multiple meshes into one.
        /// </summary>
        /// <param name="meshes"></param>
        /// <returns></returns>
        public static Mesh3D MergeMeshes(List<Mesh3D> meshes)
        {
            if (meshes.Count == 0)
                return null;

            var positions = new List<Point3D>();
            var triangleIndices = new List<int>();

            int offset = 0;
            foreach (Mesh3D m in meshes)
            {
                positions.AddRange(m.Vertices);

                foreach (int[] face in m.Faces)
                {
                    triangleIndices.Add(face[0] + offset);
                    triangleIndices.Add(face[1] + offset);
                    triangleIndices.Add(face[2] + offset);
                }

                offset = positions.Count;
            }

            return new Mesh3D(positions, triangleIndices);
        }
        
    }
}
