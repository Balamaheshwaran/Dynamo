using System;
using System.Collections.Generic;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Utilities;
using Microsoft.Practices.Prism.ViewModel;

namespace Dynamo
{
    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public class VisualizationManager : NotificationObject
    {
        #region private class members

        private static VisualizationManager instance;
        private Dictionary<string, List<object>> visualizations = new Dictionary<string, List<object>>();

        #endregion

        #region public properties

        /// <summary>
        /// A collection of objects to be stored for visualization. This property is overriden in
        /// </summary>
        public Dictionary<string, List<object>> Visualizations
        {
            get { return visualizations; }
            internal set { visualizations = value; }
        }

        public List<object> Points { get; internal set; }
        public List<object> Lines { get; internal set; }
        public List<object> Meshes { get; internal set; }
        public List<object> XAxisPoints { get; internal set; }
        public List<object> YAxisPoints { get; internal set; }
        public List<object> ZAxisPoints { get; internal set; }

        #endregion

        public VisualizationManager()
        {
            Points = new List<object>();
            Lines = new List<object>();
            Meshes = new List<object>();
            XAxisPoints = new List<object>();
            YAxisPoints = new List<object>();
            ZAxisPoints = new List<object>();
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="guid">The unique identifier of the node to be registered for visualization</param>
        public virtual void RegisterForVisualization(string id)
        {
            if (!Visualizations.ContainsKey(id))
            {
                Visualizations.Add(id, new List<object>());
            }
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="guid">The unique identifier of the node to be un-registered from visualization</param>
        public virtual void UnregisterFromVisualization(string id)
        {
            if (Visualizations.ContainsKey(id))
            {
                Visualizations[id].Clear();
                Visualizations.Remove(id);
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void Clear()
        {
            Points.Clear();
            Lines.Clear();
            Meshes.Clear();
            XAxisPoints.Clear();
            YAxisPoints.Clear();
            ZAxisPoints.Clear();
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void Draw()
        {
            //override in child classes
        }

        private void GetUpstreamIDrawable(List<IDrawable> drawables, Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;
                var drawable = node as IDrawable;

                if (node.IsVisible && drawable != null)
                    drawables.Add(drawable);

                if (node.IsUpstreamVisible)
                    GetUpstreamIDrawable(drawables, node.Inputs);
                else
                    continue; // don't bother checking if function

                //if the node is function then get all the 
                //drawables inside that node. only do this if the
                //node's workspace is the home space to avoid infinite
                //recursion in the case of custom nodes in custom nodes
                if (node is Function && node.WorkSpace == dynSettings.Controller.DynamoModel.HomeSpace)
                {
                    var func = (Function)node;
                    IEnumerable<NodeModel> topElements = func.Definition.Workspace.GetTopMostNodes();
                    foreach (NodeModel innerNode in topElements)
                    {
                        GetUpstreamIDrawable(drawables, innerNode.Inputs);
                    }
                }
            }
        }
        
    }
}
