using System;
using System.Collections.Generic;
using System.Reactive.Linq;
using System.Windows.Media.Media3D;
using System.Linq;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;

namespace Dynamo
{
    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, Visualization> visualizations 
            = new Dictionary<string, Visualization>();

        #endregion

        #region public properties

        /// <summary>
        /// A collection of objects to be stored for visualization.
        /// The first item in the tuple is is the list of geometry.
        /// The second item in the tuple is the most recent render geometry.
        /// The third item in the tuple is a flag marking the node as requiring visualization update
        /// </summary>
        public Dictionary<string, Visualization> Visualizations
        {
            get { return visualizations; }
            set { visualizations = value; }
        }

        #endregion

        public VisualizationManager()
        {
            //provide a handler for the run completed event on the controller
            dynSettings.Controller.RunCompleted += Controller_RunCompleted;
        }

        void Controller_RunCompleted(object controller, bool success)
        {
            UpdateVisualizations();
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="id">The node to register for visualization</param>
        public virtual void RegisterForVisualization(NodeModel node)
        {
            //add a key in the dictionary
            if (!Visualizations.ContainsKey(node.GUID.ToString()))
            {
                var viz = new Visualization();
                Visualizations.Add(node.GUID.ToString(), new Visualization());

                if (node is IObserver<Point3D> && node is IObserver<Mesh3D>)
                {
                    //subscribe to updates on the render description
                    viz.Description.Points.Subscribe(node as IObserver<Point3D>);
                    viz.Description.Lines.Subscribe(node as IObserver<Point3D>);
                    viz.Description.Meshes.Subscribe(node as IObserver<Mesh3D>);
                }
                
            }
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="id">The node to unregister from visualization</param>
        public virtual void UnregisterFromVisualization(NodeModel node)
        {
            if (Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Remove(node.GUID.ToString());
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Description.Clear());
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            //override in child classes
        }

        public List<IDrawable> GetUpstreamIDrawable(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<IDrawable>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;
                var drawable = node as IDrawable;

                if (node.IsVisible && drawable != null)
                    drawables.Add(drawable);

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamIDrawable(node.Inputs));
                else
                    continue; // don't bother checking if function

                //if the node is function then get all the 
                //drawables inside that node. only do this if the
                //node's workspace is the home space to avoid infinite
                //recursion in the case of custom nodes in custom nodes
                if (node is Function && node.WorkSpace == dynSettings.Controller.DynamoModel.HomeSpace)
                {
                    var func = (Function)node;
                    IEnumerable<NodeModel> topElements = func.Definition.Workspace.GetTopMostNodes();
                    foreach (NodeModel innerNode in topElements)
                    {
                        drawables.AddRange(GetUpstreamIDrawable(innerNode.Inputs));
                    }
                }
            }

            return drawables;
        }
        
    }
}
