using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows.Media.Media3D;
using System.Linq;
using Dynamo.Models;
using Dynamo.Nodes;
using Dynamo.Selection;
using Dynamo.Utilities;
using HelixToolkit.Wpf;
using Microsoft.Practices.Prism.ViewModel;

namespace Dynamo
{
    /// <summary>
    /// Visualization manager consolidates functionality for creating visualizations 
    /// of geometry and images of geometry generated by nodes.
    /// </summary>
    public abstract class VisualizationManager : NotificationObject
    {
        #region private members

        private Dictionary<string, Visualization> visualizations 
            = new Dictionary<string, Visualization>();

        #endregion

        #region public properties

        /// <summary>
        /// A dictionary of objects to be stored for visualization.
        /// </summary>
        public Dictionary<string, Visualization> Visualizations
        {
            get { return visualizations; }
            set { visualizations = value; }
        }

        #endregion

        #region events

        /// <summary>
        /// An event triggered on the completion of visualization update.
        /// </summary>
        public event EventHandler VisualizationUpdateComplete;
        
        #endregion

        protected VisualizationManager()
        {
            dynSettings.Controller.DynamoModel.NodeAdded += new NodeHandler(DynamoModel_NodeAdded);
            dynSettings.Controller.DynamoModel.NodeDeleted += new NodeHandler(DynamoModel_NodeDeleted);
            dynSettings.Controller.DynamoModel.ConnectorDeleted += new ConnectorHandler(DynamoModel_ConnectorDeleted);
            dynSettings.Controller.EvaluationCompleted += new EventHandler(Controller_EvaluationCompleted);
            dynSettings.Controller.DynamoViewModel.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(DynamoViewModel_PropertyChanged);
            dynSettings.Controller.RequestsRedraw += new EventHandler(Controller_RequestsRedraw);
            DynamoSelection.Instance.Selection.CollectionChanged += new System.Collections.Specialized.NotifyCollectionChangedEventHandler(Selection_CollectionChanged);
            dynSettings.Controller.DynamoModel.ModelCleared += new EventHandler(DynamoModel_ModelCleared);
        }

        void DynamoModel_ModelCleared(object sender, EventArgs e)
        {
            ClearVisualizations();
            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        void Selection_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            //When the selection changes we move renderables from collection
            //to another. For example, if items are added, we take the visualizations
            //from the normal collections and we add them to the selected visualization.
            //When an item is removed from the selection, we put it back in the normal collection
            if (e.NewItems != null)
            {
                foreach (object item in e.NewItems)
                {
                    var node = item as NodeModel;
                    if (item == null)
                        continue;

                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        //move points, lines, and meshes to selection visuals
                        var viz = Visualizations[node.GUID.ToString()];
                        viz.Description.SelectedPoints.AddRange(viz.Description.Points);
                        viz.Description.Points.Clear();
                        viz.Description.SelectedLines.AddRange(viz.Description.Lines);
                        viz.Description.Lines.Clear();
                        viz.Description.SelectedMeshes.AddRange(viz.Description.Meshes);
                        viz.Description.Meshes.Clear();
                    }
                } 
            }

            if (e.OldItems != null)
            {
                foreach (object item in e.OldItems)
                {
                    var node = item as NodeModel;
                    if (item == null)
                        continue;

                    if (Visualizations.ContainsKey(node.GUID.ToString()))
                    {
                        //move points, lines, and meshes
                        var viz = Visualizations[node.GUID.ToString()];
                        viz.Description.Points.AddRange(viz.Description.SelectedPoints);
                        viz.Description.SelectedPoints.Clear();
                        viz.Description.Lines.AddRange(viz.Description.SelectedLines);
                        viz.Description.SelectedLines.Clear();
                        viz.Description.Meshes.AddRange(viz.Description.SelectedMeshes);
                        viz.Description.SelectedMeshes.Clear();
                    }
                } 
            }
            

            OnVisualizationUpdateComplete(this, EventArgs.Empty);
        }

        void Controller_RequestsRedraw(object sender, EventArgs e)
        {
            UpdateVisualizations();
        }

        void DynamoViewModel_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "FullscreenWatchShowing")
            {
                if (dynSettings.Controller.DynamoViewModel.FullscreenWatchShowing == true)
                {
                    UpdateVisualizations();
                }
            }
        }

        /// <summary>
        /// Handler for the controller's EvaluationCompleted event.
        /// Requests and update to all active visualizations which are marked for update.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void Controller_EvaluationCompleted(object sender, EventArgs e)
        {
            //if there are no watches and background preview is
            //not showing, then don't update visualizations

            UpdateVisualizations();
        }

        /// <summary>
        /// Handler for the model's ConnectorDeleted event. Clears the visualization for
        /// the node at the 'end' of the connector.
        /// </summary>
        /// <param name="connector"></param>
        void DynamoModel_ConnectorDeleted(ConnectorModel connector)
        {
            if (connector.End.Owner is IDrawable)
            {
                if (Visualizations.ContainsKey(connector.End.Owner.GUID.ToString()))
                {
                    Visualizations.Remove(connector.End.Owner.GUID.ToString());
                }

                //tell the watches that they require re-binding.
                OnVisualizationUpdateComplete(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Handler for the model's NodeDeleted event. Unregisters a node from visualization.
        /// Triggers an update to the visualizations after un-registering a node
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeDeleted(NodeModel node)
        {
            if (node is IDrawable)
                UnregisterFromVisualization(node);
        }

        /// <summary>
        /// Handler for the model's NodeAdded event. Registers a node for visualization.
        /// Triggers an update to the visualizations after registering a node.
        /// </summary>
        /// <param name="node"></param>
        void DynamoModel_NodeAdded(NodeModel node)
        {
            if (node is IDrawable)
            {
                node.PropertyChanged += node_PropertyChanged;
                RegisterForVisualization(node);
            }  
        }

        /// <summary>
        /// Handler for a node model's property changed event
        /// </summary>
        /// <remarks>Used to observe changes in the nodes visualization state.
        /// </remarks>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void node_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "IsVisible")
            {
                var node = sender as NodeModel;

                if (node == null)
                    return;

                if (Visualizations.ContainsKey(node.GUID.ToString()))
                {
                    Visualization viz = Visualizations[node.GUID.ToString()];

                    if (!node.IsVisible)
                    {
                        //clear the render description
                        viz.Description.Clear();
                    }
                    if (node.IsVisible)
                    {
                        viz.RequiresUpdate = true;
                    }

                    UpdateVisualizations();
                }
            }
            else if (e.PropertyName == "IsUpstreamVisible")
            {
                //just call for an update
                //the gatherupstream method when called by
                //the watch will filter the visualiations for
                //upstream visibility.
                UpdateVisualizations();
            }
        }

        /// <summary>
        /// Register a node for visualization. Internally adds a list to the 
        /// visualizations dictionary keyed by the provided id.
        /// </summary>
        /// <param name="id">The node to register for visualization</param>
        public virtual void RegisterForVisualization(NodeModel node)
        {
            //add a key in the dictionary
            if (!Visualizations.ContainsKey(node.GUID.ToString()))
            {
                var viz = new Visualization {RequiresUpdate = false};
                Visualizations.Add(node.GUID.ToString(), viz);
            }
        }

        /// <summary>
        /// Unregister a node from visualization. Internally removes geometry from the visualizations dictionary
        /// and ensures that geometry representations are unbound from views and deleted.
        /// </summary>
        /// <param name="id">The node to unregister from visualization</param>
        public virtual void UnregisterFromVisualization(NodeModel node)
        {
            if (Visualizations.ContainsKey(node.GUID.ToString()))
            {
                Visualizations.Remove(node.GUID.ToString());
            }
        }

        /// <summary>
        /// Clear the contents of all lists containing render geometry.
        /// </summary>
        public void ClearVisualizations()
        {
            Visualizations.Values.ToList().ForEach(x=>x.Description.Clear());
        }

        /// <summary>
        /// Create visualizations including tesselated geometry representations
        /// and node preview imagery. Drawing will be overidden in child classes to draw geometry 
        /// according to the host's geometry types.
        /// </summary>
        public virtual void UpdateVisualizations()
        {
            var worker = new BackgroundWorker();
            worker.DoWork += VisualizationUpdateThread;

            worker.RunWorkerAsync();
        }

        protected virtual void VisualizationUpdateThread(object s, DoWorkEventArgs args)
        {
        }

        /// <summary>
        /// When a node enters it's evaluation, it is flagged for requiring update.
        /// We dump the geometry collection and the render descption.
        /// This ensures that, if the node errors, it will render nothing.
        /// </summary>
        /// <param name="node">The node whose visualization will be updated.</param>
        public void MarkForUpdate(NodeModel node)
        {
            //re-register the node if this call is coming from a place
            //where the node got dropped from visualization but then
            //was re-added
            if(!visualizations.ContainsKey(node.GUID.ToString()))
                RegisterForVisualization(node);

            var v = Visualizations[node.GUID.ToString()];
            
            //don't set for update if it's not visible
            //the node's evaluate will fill the geometry collection
            //but not visualizations will be calculated for the node
            if(node.IsVisible)
                v.RequiresUpdate = true;

            //clear the gometry collection and the render description
            //the geometry collection will be filled during update.
            v.Geometry.Clear();
            v.Description.Clear();
        }

        /// <summary>
        /// Aggregates all upstream geometry for the given node.
        /// </summary>
        /// <param name="node">The node whose upstream geometry you need.</param>
        /// <returns>A render description containing all upstream geometry.</returns>
        public RenderDescription RenderUpstream(NodeModel node)
        {
            var watch = new Stopwatch();
            watch.Start();

            var drawables = GetUpstreamIDrawableIds(node.Inputs);
            
            var ids = from viz in dynSettings.Controller.VisualizationManager.Visualizations
                      where drawables.Contains(viz.Key)
                      select viz;

            var rd = new RenderDescription();

            var keyValuePairs = ids as KeyValuePair<string, Visualization>[] ?? ids.ToArray();

            var pts = keyValuePairs.SelectMany(x => x.Value.Description.Points).ToList();
            var lines = keyValuePairs.SelectMany(x => x.Value.Description.Lines).ToList();
            var meshes = keyValuePairs.SelectMany(x => x.Value.Description.Meshes).ToList();
            var xs = keyValuePairs.SelectMany(x => x.Value.Description.XAxisPoints).ToList();
            var ys = keyValuePairs.SelectMany(x => x.Value.Description.YAxisPoints).ToList();
            var zs = keyValuePairs.SelectMany(x => x.Value.Description.ZAxisPoints).ToList();
            var pts_sel = keyValuePairs.SelectMany(x => x.Value.Description.SelectedPoints).ToList();
            var lines_sel = keyValuePairs.SelectMany(x => x.Value.Description.SelectedLines).ToList();
            var mesh_sel = keyValuePairs.SelectMany(x => x.Value.Description.SelectedMeshes).ToList();

            rd.Points.AddRange(pts);
            rd.Lines.AddRange(lines);
            rd.Meshes.AddRange(meshes);
            rd.XAxisPoints.AddRange(xs);
            rd.YAxisPoints.AddRange(ys);
            rd.ZAxisPoints.AddRange(zs);
            rd.SelectedPoints.AddRange(pts_sel);
            rd.SelectedLines.AddRange(lines_sel);
            rd.SelectedMeshes.AddRange(mesh_sel);

            watch.Stop();
            Debug.WriteLine(string.Format("{0} ellapsed for aggregating geometry for watch.", watch.Elapsed));

            return rd;
        }

        /// <summary>
        /// Gathers the Ids of the upstream drawable nodes.
        /// </summary>
        /// <param name="inputs">A dictionary describing the inputs on the node.</param>
        /// <returns>A collection of strings.</returns>
        private List<string> GetUpstreamIDrawableIds(Dictionary<int, Tuple<int, NodeModel>> inputs)
        {
            var drawables = new List<string>();

            foreach (KeyValuePair<int, Tuple<int, NodeModel>> pair in inputs)
            {
                if (pair.Value == null)
                    continue;

                NodeModel node = pair.Value.Item2;
                var drawable = node as IDrawable;

                if(drawable != null)
                    drawables.Add(node.GUID.ToString());

                if (node.IsUpstreamVisible)
                    drawables.AddRange(GetUpstreamIDrawableIds(node.Inputs));
                //else
                //    continue; // don't bother checking if function

                //if the node is function then get all the 
                //drawables inside that node. only do this if the
                //node's workspace is the home space to avoid infinite
                //recursion in the case of custom nodes in custom nodes
                if (node is Function && node.WorkSpace == dynSettings.Controller.DynamoModel.HomeSpace)
                {
                    var func = (Function)node;
                    IEnumerable<NodeModel> topElements = func.Definition.Workspace.GetTopMostNodes();
                    foreach (NodeModel innerNode in topElements)
                    {
                        var drawableInner = innerNode as IDrawable;

                        if (drawableInner != null)
                            drawables.Add(innerNode.GUID.ToString());

                        if (node.IsUpstreamVisible)
                            drawables.AddRange(GetUpstreamIDrawableIds(innerNode.Inputs));
                    }
                }
            }

            return drawables;
        }

        /// <summary>
        /// A utility method for merging multiple meshes into one.
        /// </summary>
        /// <param name="meshes"></param>
        /// <returns></returns>
        public static MeshGeometry3D MergeMeshes(List<MeshGeometry3D> meshes)
        {
            if (meshes.Count == 0)
                return null;

            int offset = 0;

            var builder = new MeshBuilder();

            foreach (MeshGeometry3D m in meshes)
            {
                foreach (var pos in m.Positions)
                {
                    builder.Positions.Add(pos);
                }
                foreach (var index in m.TriangleIndices)
                {
                    builder.TriangleIndices.Add(index + offset);
                }
                foreach (var norm in m.Normals)
                {
                    builder.Normals.Add(norm);
                }
                foreach (var tc in m.TextureCoordinates)
                {
                    builder.TextureCoordinates.Add(tc);
                }

                offset += m.Positions.Count;
            }

            return builder.ToMesh(false);
        }

        /// <summary>
        /// Called when the update of visualizations is complete.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void OnVisualizationUpdateComplete(object sender, EventArgs e)
        {
            if (VisualizationUpdateComplete != null)
                VisualizationUpdateComplete(sender, e);
        }

        /// <summary>
        /// Helper method to total the current visualizations.
        /// </summary>
        /// <param name="pointCount"></param>
        /// <param name="lineCount"></param>
        /// <param name="meshCount"></param>
        /// <param name="xCount"></param>
        /// <param name="yCount"></param>
        /// <param name="zCount"></param>
        public void GetVisualizationCounts(
            out int pointCount, out int lineCount, out int meshCount, out int xCount, out int yCount, out int zCount)
        {
            var points = Visualizations.SelectMany(x => x.Value.Description.Points);
            var lines = Visualizations.SelectMany(x => x.Value.Description.Lines);
            var meshes = Visualizations.SelectMany(x => x.Value.Description.Meshes);
            var xs = Visualizations.SelectMany(x => x.Value.Description.XAxisPoints);
            var ys = Visualizations.SelectMany(x => x.Value.Description.YAxisPoints);
            var zs = Visualizations.SelectMany(x => x.Value.Description.ZAxisPoints);

            pointCount = points.Count();
            lineCount = lines.Count();
            meshCount = meshes.Count();
            xCount = xs.Count();
            yCount = ys.Count();
            zCount = zs.Count();
        }
    }
}
